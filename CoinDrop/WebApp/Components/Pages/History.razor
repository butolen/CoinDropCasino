@page "/history"
@using System.Security.Claims
@using CoinDrop.services.interfaces
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Components.Authorization
@using WebApp.services.dtos
@rendermode InteractiveServer
@attribute [Authorize]
@inject ITransactionHistoryService HistoryService
@inject AuthenticationStateProvider AuthStateProvider
@inject NavigationManager Nav

<div class="history-page">
    <div class="panel">
        <div class="panel-title">HISTORY</div>

        <a class="game-history-btn" href="/game-history">GAME HISTORY</a>

        <div class="section-title">TRANSACTION HISTORY</div>

        <div class="filters">
            <div class="field">
                <label>Action</label>
                <select @bind="_query.Action">
                    <option value="@TransactionActionFilter.All">All</option>
                    <option value="@TransactionActionFilter.Deposit">Deposit</option>
                    <option value="@TransactionActionFilter.Withdrawal">Withdrawal</option>
                </select>
            </div>

            <div class="field">
                <label>Type</label>
                <select @bind="_query.Type">
                    <option value="@TransactionTypeFilter.All">All</option>
                    <option value="@TransactionTypeFilter.Physical">Physical</option>
                    <option value="@TransactionTypeFilter.Crypto">Crypto</option>
                </select>
            </div>
            

            <div class="field">
                <label>Min Deposit (EUR)</label>
                <input type="number"
                       step="0.01"
                       min="0"
                       @bind="_minDepositEur" />
            </div>

            <div class="filter-actions">
                <button class="btn-primary" @onclick="ApplyFilters">Apply</button>
                <button class="btn-ghost" @onclick="ResetFilters">Reset</button>
            </div>
        </div>

        <div class="table-wrap">
            <table class="tx-table">
                <thead>
                    <tr>
                        <th>Action</th>
                        <th>Type</th>
                        <th class="num">Amount (EUR)</th>
                        <th>Asset Type</th>
                        <th>Network</th>
                        <th>Timestamp (Local)</th>
                        <th>Tx Hash</th>
                    </tr>
                </thead>
                <tbody>
                    @if (_loading)
                    {
                        <tr><td colspan="7" class="muted">Loading...</td></tr>
                    }
                    else if (_rows.Length == 0)
                    {
                        <tr><td colspan="7" class="muted">No transactions found.</td></tr>
                    }
                    else
                    {
                        @foreach (var r in _rows)
                        {
                            <tr>
                                <td>@r.Action</td>
                                <td>@r.Type</td>
                                <td class="num">@FormatEur(r.EurAmount)</td>
                                <td>@r.AssetType</td>
                                <td>@(string.IsNullOrWhiteSpace(r.Network) ? "—" : r.Network)</td>
                                <td>@ToLocal(r.TimestampUtc).ToString("dd.MM.yyyy HH:mm")</td>
                                <td class="tx-hash">
                                    @if (!string.IsNullOrWhiteSpace(r.TxHash))
                                    {
                                        <span title="@r.TxHash">@r.TxHash</span>
                                    }
                                    else
                                    {
                                        <span class="muted">—</span>
                                    }
                                </td>
                            </tr>
                        }
                    }
                </tbody>
            </table>
        </div>
    </div>
</div>
@code {
    private bool _loading;
    private TransactionHistoryRowDto[] _rows = Array.Empty<TransactionHistoryRowDto>();

    private TransactionHistoryQuery _query = new()
    {
        Action = TransactionActionFilter.All,
        Type = TransactionTypeFilter.All
    };

    private DateTime? _fromLocal;
    private DateTime? _toLocal;
    private double? _minDepositEur;

    // ✅ verhindert parallele LoadAsync Aufrufe (Reload/Render/Click)
    private readonly SemaphoreSlim _loadLock = new(1, 1);

    // ✅ verhindert doppeltes Initial-Laden bei InteractiveServer Reload
    private bool _loadedOnce;

    protected override Task OnInitializedAsync()
    {
        // NICHT laden hier
        return Task.CompletedTask;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender || _loadedOnce) return;
        _loadedOnce = true;

        await LoadAsync();
        await InvokeAsync(StateHasChanged);
    }

    private async Task ApplyFilters()
    {
        SyncFiltersIntoQuery();
        await LoadAsync();
    }

    private async Task ResetFilters()
    {
        _query = new TransactionHistoryQuery
        {
            Action = TransactionActionFilter.All,
            Type = TransactionTypeFilter.All
        };

        _fromLocal = null;
        _toLocal = null;
        _minDepositEur = null;

        await LoadAsync();
    }

    private async Task LoadAsync()
    {
        await _loadLock.WaitAsync();
        try
        {
            _loading = true;

            var userId = await GetCurrentUserIdAsync();
            if (userId <= 0)
            {
                _rows = Array.Empty<TransactionHistoryRowDto>();
                return;
            }

            var result = await HistoryService.GetForUserAsync(userId, _query);
            _rows = result.Items;
        }
        finally
        {
            _loading = false;
            _loadLock.Release();
        }
    }

    private void SyncFiltersIntoQuery()
    {
        _query.FromUtc = _fromLocal.HasValue ? LocalToUtc(_fromLocal.Value) : null;
        _query.ToUtc = _toLocal.HasValue ? LocalToUtc(_toLocal.Value) : null;
        _query.MinDepositEur = _minDepositEur.HasValue ? Math.Max(0, _minDepositEur.Value) : null;
    }

    private static DateTime LocalToUtc(DateTime local)
        => DateTime.SpecifyKind(local, DateTimeKind.Local).ToUniversalTime();

    private static DateTime ToLocal(DateTime utc)
        => DateTime.SpecifyKind(utc, DateTimeKind.Utc).ToLocalTime();

    private static string FormatEur(double eur)
        => eur.ToString("0.00") + " €";

    private async Task<int> GetCurrentUserIdAsync()
    {
        try
        {
            var state = await AuthStateProvider.GetAuthenticationStateAsync();
            var user = state.User;

            if (user?.Identity?.IsAuthenticated != true)
                return 0;

            var idStr =
                user.FindFirstValue(ClaimTypes.NameIdentifier)
                ?? user.FindFirstValue("sub")
                ?? user.FindFirstValue("userid");

            return int.TryParse(idStr, out var id) ? id : 0;
        }
        catch
        {
            return 0;
        }
    }
}